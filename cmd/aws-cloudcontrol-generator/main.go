package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io/ioutil"
	"text/template"
	"time"

	"github.com/isan-rivkin/surf/lib/awsu"
	log "github.com/sirupsen/logrus"
)

const (
	templateData = `package cloudformationgenerated

/*
THIS FILE WAS AUTO GENERATED AT {{ .now }}

Do not edit this file, run "go generate" to re-generate this file with an
updated resources of CloudFormation list.
*/

// resource types https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html
type generatedCCResourceProperty struct {
	//service-provider::service-name::data-type-name
	ServiceProvider          string
	ServiceName              string
	DataTypeName             string
	ResourceProvisioningType string
}
// Define the main struct
type resourceSchema struct {
	TypeIdentifier           string
	RawSchemaJson            string
	AdditionalRequiredFields []string
}

var GenCloudformationProperties = []generatedCCResourceProperty{ 
	{{ range $i, $r := .resources -}}
	{
		ServiceProvider: "{{ $r.ServiceProvider }}",
		ServiceName: "{{ $r.ServiceName }}",
		DataTypeName: "{{ $r.DataTypeName}}",
		ResourceProvisioningType: "{{ $r.ResourceProvisioningType }}",
	},
	{{ end -}}
}

var GenCloudFormationResourceSchemas = map[string]resourceSchema{
	{{- range $i, $r := .descriptions }}
	"{{ $r.TypeIdentifier }}": {
		AdditionalRequiredFields: []string{
			{{- range $field := $r.AdditionalRequiredFields }}
			"{{ $field }}",
			{{- end }}
		},
	},
	{{- end }}
}
`
)

func createFile(args map[string]interface{}) {
	tmpl := template.Must(template.New("").Parse(templateData))
	buf := bytes.Buffer{}

	if err := tmpl.Execute(&buf, args); err != nil {
		panic(err)
	}

	fileBytes, err := format.Source(buf.Bytes())
	if err != nil {
		panic(fmt.Errorf("formatting go source: %w", err))
	}

	newFile := "./lib/awsu/cloudformationgenerated/cloudformation_resources.gen.go"

	_ = ioutil.WriteFile(newFile, fileBytes, 0644)
	fmt.Printf("Generated file: %s\n", newFile)
}

func main() {
	log.Info("running code generation for cloudformation resources")
	auth, err := awsu.NewSessionInput("", "")
	if err != nil {
		panic(fmt.Errorf("creating session in AWS: %w", err))
	}
	cfClient, err := awsu.NewCloudFormation(auth)
	if err != nil {
		panic(fmt.Errorf("creating cloudformation client: %w", err))
	}
	cfApi := awsu.NewCloudFormationAPI(cfClient)
	resp, err := cfApi.GetAllSupportedCloudControlAPIResources()
	if err != nil {
		panic(fmt.Errorf("getting all supported cloud control api resources: %w", err))
	}
	resources, err := resp.GetResources()
	if err != nil {
		panic(fmt.Errorf("parsing resources: %w", err))
	}
	// create channel in the size of resources
	descriptions := make([]*awsu.ResourceSchema, 0, len(resources))
	for _, r := range resources {
		retryAttempts := 5
		for i := 0; i < retryAttempts; i++ {
			desc, err := cfApi.DescribeResourceType(r)
			if err != nil {
				if errors.Is(err, awsu.ErrCloudFormationRateLimit) {
					// retry
					time.Sleep(1 * time.Second)
					fmt.Printf("retrying rate limit %d/%d '%s'\n", i, retryAttempts, r.String())
					continue
				} else {
					panic(fmt.Errorf("describing resource type: %w", err))
				}
			}
			resourceSchema, err := awsu.NewResourceSchemaFromDescribe(r, desc)
			if err != nil {
				panic(fmt.Errorf("creating resource schema from describe: %w", err))
			}
			fmt.Printf("Described Resource: %s Props %s\n", resourceSchema.AdditionalRequiredFields, r.String())
			descriptions = append(descriptions, resourceSchema)
			break
		}
	}

	fmt.Println("done descriptions: ", len(descriptions))
	args := map[string]interface{}{
		"resources":    resources,
		"descriptions": descriptions,
		"now":          time.Now().Format("2006-01-02 15:04:05"),
	}

	createFile(args)
}
